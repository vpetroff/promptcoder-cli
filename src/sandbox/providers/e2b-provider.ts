import { SandboxProvider, Sandbox, SandboxConfig, FileMap } from '../types';

export class E2BProvider implements SandboxProvider {
  name = 'e2b';
  private apiKey: string;
  private baseUrl = 'https://api.e2b.dev';

  constructor(apiKey: string) {
    this.apiKey = apiKey;
  }

  async createSandbox(config: SandboxConfig): Promise<Sandbox> {
    const response = await this.makeRequest('POST', '/sandboxes', {
      template: config.template || 'node20',
      metadata: {
        name: config.name || 'PromptCoder Sandbox',
        description: config.description || 'Generated by PromptCoder CLI',
        created_by: 'promptcoder-cli'
      }
    });

    return {
      id: response.sandboxID,
      name: config.name || `Sandbox ${response.sandboxID.slice(0, 8)}`,
      url: `https://${response.sandboxID}.e2b.dev`,
      status: 'creating',
      provider: this.name,
      template: config.template || 'node20',
      createdAt: new Date(),
      updatedAt: new Date(),
      metadata: response
    };
  }

  async deploySandbox(sandbox: Sandbox, files: FileMap): Promise<string> {
    // Upload files to the sandbox (skip null values as they indicate deletions)
    const uploadPromises = Object.entries(files)
      .filter(([, content]) => content !== null)
      .map(([path, content]) => this.uploadFile(sandbox.id, path, content!));

    await Promise.all(uploadPromises);

    // Start the sandbox if it has a start command
    if (sandbox.metadata?.startCommand) {
      await this.executeCommand(sandbox.id, sandbox.metadata.startCommand);
    }

    return sandbox.url;
  }

  async getSandbox(id: string): Promise<Sandbox> {
    const response = await this.makeRequest('GET', `/sandboxes/${id}`);
    
    return {
      id: response.sandboxID,
      name: response.metadata?.name || `Sandbox ${id.slice(0, 8)}`,
      url: `https://${id}.e2b.dev`,
      status: this.mapStatus(response.status),
      provider: this.name,
      template: response.template,
      createdAt: new Date(response.createdAt),
      updatedAt: new Date(response.updatedAt || response.createdAt),
      metadata: response
    };
  }

  async deleteSandbox(id: string): Promise<void> {
    await this.makeRequest('DELETE', `/sandboxes/${id}`);
  }

  async syncFiles(id: string, files: FileMap): Promise<void> {
    const promises = Object.entries(files).map(([path, content]) => {
      if (content === null) {
        // Handle file deletion
        return this.deleteFile(id, path);
      } else {
        // Handle file upload/update
        return this.uploadFile(id, path, content);
      }
    });

    await Promise.all(promises);
  }

  async listSandboxes(): Promise<Sandbox[]> {
    const response = await this.makeRequest('GET', '/sandboxes');
    
    return response.sandboxes.map((s: any) => ({
      id: s.sandboxID,
      name: s.metadata?.name || `Sandbox ${s.sandboxID.slice(0, 8)}`,
      url: `https://${s.sandboxID}.e2b.dev`,
      status: this.mapStatus(s.status),
      provider: this.name,
      template: s.template,
      createdAt: new Date(s.createdAt),
      updatedAt: new Date(s.updatedAt || s.createdAt),
      metadata: s
    }));
  }

  async getTemplates(): Promise<string[]> {
    // E2B common templates
    return [
      'node20',
      'python3',
      'nextjs',
      'react',
      'vue',
      'angular',
      'express',
      'fastapi',
      'django',
      'flask'
    ];
  }

  private async uploadFile(sandboxId: string, filePath: string, content: string | Buffer): Promise<void> {
    const contentStr = content instanceof Buffer ? content.toString('utf8') : content;
    
    await this.makeRequest('POST', `/sandboxes/${sandboxId}/files`, {
      path: filePath,
      content: contentStr
    });
  }

  private async deleteFile(sandboxId: string, filePath: string): Promise<void> {
    try {
      await this.makeRequest('DELETE', `/sandboxes/${sandboxId}/files`, {
        path: filePath
      });
    } catch (error) {
      // If the file doesn't exist, that's fine - it's already "deleted"
      console.warn(`Warning: Could not delete file ${filePath} from sandbox ${sandboxId}:`, error);
    }
  }

  private async executeCommand(sandboxId: string, command: string): Promise<void> {
    await this.makeRequest('POST', `/sandboxes/${sandboxId}/commands`, {
      command,
      background: true
    });
  }

  private mapStatus(e2bStatus: string): Sandbox['status'] {
    switch (e2bStatus?.toLowerCase()) {
      case 'starting':
      case 'created':
        return 'creating';
      case 'running':
        return 'running';
      case 'stopped':
        return 'stopped';
      case 'error':
      case 'failed':
        return 'error';
      default:
        return 'creating';
    }
  }

  private async makeRequest(method: string, endpoint: string, body?: any): Promise<any> {
    const url = `${this.baseUrl}${endpoint}`;
    const options: RequestInit = {
      method,
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      }
    };

    if (body) {
      options.body = JSON.stringify(body);
    }

    const response = await fetch(url, options);
    
    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`E2B API Error: ${response.status} ${response.statusText} - ${errorData.message || 'Unknown error'}`);
    }

    return response.json();
  }
}